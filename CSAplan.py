""" 
Program. CSAplan.python3
Programmed by: Daniel Botz      Student #: 200035647
Purpose: This program should help determine the optimal crop arrangement for a
 community supported agriculture system. It will maximize profit made off
 culinary fruits and vegetables sold while meeting the returns of the
 subscribers and utilizing the limited farmland available.

Program input:
    File input data - C:\Users\Daniel\Documents\vegetableData.txt
    User input data - Which crop from vegetable data file to grow
                    - Length and width of available farmland
                    - Number of people who purchased shares from the CSA program
Program output:
    - Coefficient matrix with current row configurations (B)
    - Profit from each type of row configuration planted (c)
    - Minimum amount of produce given to shareholders (b)
    - The Basic Feasible Solution (BFS)
    - The profit obtained from the BFS
"""
from numpy import *
from math import *

def MatxPrint(label, Matx, money):
    """Each entry in a matrix will be printed as a number with 2 decimal places
    through this function."""
    print ("%-6s" % (label))
    Matx4printing = zeros((shape(Matx)))
    for row in range((size(Matx,0))):
        if len(shape(row)) >= 1:
            for entr in range(len(row)): 
                Matx4printing[row][entr] = round(Matx[row][entr], 2)
        else:
            Matx4printing[row] = Matx[row]
    if money == 1:
        for x in nditer(Matx4printing):
            print ("$%6.2f" % (x)) # Print each value as US currency.
    else:
        for row in Matx4printing:
            print row # Print each value as is.
            
def csaLP(vegNo, vegBase, shares, gardenL, gardenW):
    """Creates the LP format with the row-based decisions variables."""
    Bmatrix = rowLayout(vegNo, vegBase[:,0], gardenL)
    # The coefficient matrix with the columns generated by the rowLayout function.
    rhs = vstack((ones((vegNo,1)) * shares * 10, gardenW)) # The constraint vector
    # Note that over the season each shareholder receives 10 of each crop grown.
    returnShares = dot(transpose(rhs[:-1]), vegBase[:,4])
    # This above is the profit loss from produce grown that was given away to
    # shareholders because of their support to the CSA
    feePayments = shares * 417.5 # Money receive from shareholder subscription fees.
    rowTotal = zeros((vegNo, len(Bmatrix[1])))
    for f in range(combination(vegNo,2)):
        tempArray = transpose(vstack((Bmatrix[:-1,f], vegBase[:,3], vegBase[:,4])))
        rowTotal[:,f] = prod(tempArray, 1, float)
    cmatrix = sum(rowTotal, 0, float) # the objective value vector.
    MatxPrint("B =", Bmatrix, 0) 
    MatxPrint("c =", cmatrix, 1)
    MatxPrint("b =", rhs, 0)
    results = intSowSeeds(Bmatrix, cmatrix, rhs)
    MatxPrint("BFS =", results[0], 0)
    grossProfit = results[1] + feePayments - returnShares
    print ("%13s$%6.2f%25s$%4.2f%25s$%5.2f%15s$%7.2f" % ("Base Profit: ", 
    results[1], " Shareholder Cost: ", returnShares, 
    "\nSubscription Payments: ", feePayments, " Gross Profit: ", grossProfit))
    
def combination(n,r):
    rowplan = math.factorial(n)/(math.factorial(r) * math.factorial(n-r))
    return rowplan
        
def rowLayout(cropNum, cropSp, length):
    """This creates the arrangement of crops in a given row. For now, all combinations
    of 2 vegetables evenly distributed in a row forms the initial columns."""
    dirtPatch = zeros((cropNum+1,0))
    for veg1 in range(cropNum):
        for veg2 in range(veg1, cropNum):
            if veg2 <> veg1:
                dirtRow = zeros((cropNum+1, 1))
                # This fills up a row with an about even amount of each crop.
                plant = floor(length/((cropSp[veg1]+cropSp[veg2])/12)) # Inch to feet
                dirtRow[veg1] = plant
                dirtRow[veg2] = plant
                dirtRow[cropNum] = max(cropSp[veg1]/12, cropSp[veg2]/12)
                # The width of each row is determined by the crop in that row 
                # with the largest growing area. For example: if tomatoes and
                # squash are planted in the same row, the width for squash (3 feet)
                # is used for row width.
                dirtPatch = hstack((dirtPatch, dirtRow))
    return dirtPatch
             
def intSowSeeds(BM, Cv, bv):
    """An initial basic feasiable solution for the given variables is calculated."""
    cLeng = len(Cv) # The length of vector (Cv)
    gWidth = bv[-1] # The garden's width
    cropRows = BM[:-1]
    space2Wid = BM[-1] # The last row of the coefficent matrix.
    bfs = zeros((shape(Cv)))
    y = 0
    # To fill up the BFS, we first make sure shareholder returns are satisfied.
    while any(dot(cropRows, bfs) <= bv[:-1]):
        bfs[y] += 2
        y = mod(y+1, cLeng) # This module keeps the index number y in bounds.
    # The rest for the BFS is filled up to the width limits of the available land.
    while dot(space2Wid, bfs) < gWidth:
        bfs[y] += 1
        y = mod(y+1, cLeng)   
    if dot(space2Wid, bfs) > gWidth:
        bfs[y] -= 1                  
    sert = vstack((Cv,bfs))
    profit = sum(prod(sert, 0, float), 0, float) # The profit from the vegetables
    # grown in the row configurations given by the BFS.
    return [bfs, profit]
             
def main():
    filename = raw_input("Enter vegetable information: ") 
    inputfile = open(filename, 'r')
    cSelected = zeros((0,1)) # The list of numbers associated with chosen vegetables.
    fullMatx = ones((0, 5)) # All numeric data for produce goes in here.
    for line in inputfile: # Here the names and the number of each veggie is
        # displayed so the user can choose what goes into the garden initially.
        dispdata = line.split(', ')
        for num in range(2, len(dispdata)): 
            dispdata[num] = float(dispdata[num]) # Produce stats now become 
            # floating-point data.
        print("%-16s%-2s" % (dispdata[0], dispdata[1]))
        fullMatx = vstack((fullMatx, dispdata[2:len(line)]))
# From left to right the numbers represent: Area required for plants, height of
# individul produce, circumference of individual produce, average yield per
# plant, and price for each plant not given to shareholders. 
# Here the user selects which vegetables go into the garden.
    cropNo = input("How many vegetables do you want to start with?: ") # vegNo
    print ("Which ones? (Enter in the x# to the right of the \
desired vegetable.)")
    for c in range(cropNo):
        veggie = input("-> x")
        cSelected = vstack((cSelected, int(veggie)))
# Here the produce data is prepared for evaluation by the LP.
    selectedVeg = zeros((cropNo,5))
    otherVeg = zeros((size(fullMatx,0)-cropNo,5)) 
    rowS = 0 # This keeps track of the rows in the selectedVeg matrix.
    rowO = 0 # This keeps track of the rows in the otherVeg matrix.
    for valu in range(size(fullMatx,0)):
        if (valu+1) in cSelected:
            selectedVeg[rowS, 0:5] = fullMatx[valu, 0:5] # the initial variables for the vegBase.
            rowS += 1 
        else:
            otherVeg[rowO, 0:5] = fullMatx[valu, 0:5] # the variables saved for 
                                                    # column generation.
            rowO += 1    
    print ("What are the dimension of the available, futile land?")
    Width =  input("The width (in feet): ") # gardenW     
    Length = input("The length (in feet): ") # gardenL
    # The number of shareholders will be important to the constraint vector.
    shareholders = input("How many subscriptions to this CSA have been sold? ")
    csaLP(cropNo, selectedVeg, int(shareholders), float(Length), float(Width))
    
main()